{"version":3,"sources":["rehook/dom.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha/or-spec-impl","cljs.core/symbol?","cljs.core/map?","cljs.spec.alpha.tuple_impl","cljs.spec.alpha/cat-impl","cljs.spec.alpha/rep-impl","cljs.core/any?","var_args","G__23777","rehook.dom/eval-hiccup","args-arr__4757__auto__","len__4736__auto__","i__4737__auto__","argseq__4758__auto__","cljs.core/IndexedSeq","seq23772","G__23773","cljs.core/first","cljs.core/next","G__23774","G__23775","self__4723__auto__","$","e","cljs.core/seq?","p1__23767#","cljs.core.map","cljs.core.apply","cljs.core/vector?","props","rehook.dom.eval_hiccup","children","cljs.core.mapcat","child","cljs.core/seq","p1__23769#","cljs.core.filter","cljs.core/identity","cljs.core/cons","rehook.dom/rehook-meta","m","_","cljs.core.assoc","rehook.dom/as-element","ctx","form","temp__5733__auto__","cljs.core.get","cljs.core.ex_info","cljs.core/keys"],"sourcesContent":["(ns rehook.dom\n  (:require [clojure.spec.alpha :as s]))\n\n(s/def ::arg\n  (s/or :symbol? symbol?\n        :map?    map?))\n\n(s/def ::args\n  (s/or\n   :two-arity   (s/tuple ::arg ::arg)\n   :three-arity (s/tuple ::arg ::arg symbol?)))\n\n(s/def ::defui\n  (s/cat :name symbol?\n         :args ::args\n         :body (s/* any?)))\n\n(s/def ::ui\n  (s/cat :args ::args\n         :body (s/* any?)))\n\n(s/def ::html\n  (s/cat :render-fn symbol?\n         :component any?))\n\n(defn eval-hiccup\n  ([$ e]\n   (cond\n     (seq? e)\n     (map #(apply $ %) e)\n\n     (vector? e)\n     (apply eval-hiccup $ e)\n\n     (or (nil? e) (string? e) (number? e))\n     e\n\n     :else ($ e)))\n\n  ([$ e props]\n   (if (map? props)\n     ($ e props)\n     (eval-hiccup $ e {} props)))\n\n  ([$ e props & children]\n   (if (map? props)\n     (apply $ e props\n            (->> children\n                 (mapcat (fn [child]\n                           (cond\n                             (and (vector? child) (seq child))\n                             [(apply eval-hiccup $ child)]\n\n                             (seq? child)\n                             (map #(eval-hiccup $ %) child)\n\n                             :else\n                             [(eval-hiccup $ child)])))\n                 (filter identity)))\n\n     (apply eval-hiccup $ e {} (cons props children)))))\n\n#?(:clj\n   (defmacro html [$ component]\n     (s/assert* ::html [$ component])\n     `(apply eval-hiccup ~$ ~component)))\n\n(defn rehook-meta\n  [m props _]\n  (assoc m :react/props props))\n\n(defn as-element\n  \"Turns a vector of Hiccup syntax into a React element.\"\n  [ctx form]\n  (if-let [$ (get ctx :rehook.dom/bootstrap)]\n    (eval-hiccup $ form)\n    (if ctx\n      (throw (ex-info \"ctx argument to as-element null. Have you passed in the ctx map?\" {}))\n      (throw (ex-info \"as-element requires :rehook.dom/bootstrap key in ctx map. Are you you using defui?\"\n                      {:keys (keys ctx) :ctx ctx})))))\n\n#?(:clj\n   (defmacro defui\n     [name [ctx props $?] & body]\n     (if $?\n       (do (s/assert* ::defui [name [ctx props $?] body])\n           `(def ~name\n              ^{:rehook/component true\n                :rehook/name      ~(str name)}\n              (fn ~name [ctx# $#]\n                (let [~ctx (dissoc ctx# :rehook.dom/props)\n                      ~$? $#]\n                  (fn ~(gensym name) [props#]\n                    (let [~props (vary-meta (get ctx# :rehook.dom/props {}) rehook-meta props# ctx#)]\n                      ~@body))))))\n\n       (do (s/assert* ::defui [name [ctx props] body])\n           (let [$ (gensym '$)\n                 effects (butlast body)\n                 hiccup (last body)]\n             `(def ~name\n                ^{:rehook/component true\n                  :rehook/name      ~(str name)}\n                (fn ~name [ctx# $#]\n                  (let [~ctx (dissoc ctx# :rehook.dom/props)\n                        ~$ $#]\n                    (fn ~(gensym name) [props#]\n                      (let [~props (vary-meta (get ctx# :rehook.dom/props {}) rehook-meta props# ctx#)]\n                        ~@effects\n                        (html ~$ ~hiccup)))))))))))\n\n#?(:clj\n   (defmacro ui\n     [[ctx props $?] & body]\n     (if $?\n       (let [id (gensym \"ui\")]\n         (s/assert* ::ui [[ctx props $?] body])\n         `(with-meta\n           (fn ~id [ctx# $#]\n             (let [~ctx (dissoc ctx# :rehook.dom/props)\n                   ~$? $#]\n               (fn ~(gensym id) [props#]\n                 (let [~props (vary-meta (get ctx# :rehook.dom/props {}) rehook-meta props# ctx#)]\n                   ~@body))))\n           {:rehook/component true\n            :rehook/name      ~(str id)}))\n\n       (let [id      (gensym \"ui\")\n             $       (gensym '$)\n             effects (butlast body)\n             hiccup  (last body)]\n         (s/assert* ::ui [[ctx props] body])\n         `(with-meta\n           (fn ~id [ctx# $#]\n             (let [~ctx (dissoc ctx# :rehook.dom/props)\n                   ~$ $#]\n               (fn ~(gensym id) [props#]\n                 (let [~props (vary-meta (get ctx# :rehook.dom/props {}) rehook-meta props# ctx#)]\n                   ~@effects\n                   (html ~$ ~hiccup)))))\n           {:rehook/component true\n            :rehook/name      ~(str id)})))))"]}