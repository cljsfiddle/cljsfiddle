{"version":3,"sources":["cljspad/env.cljs"],"mappings":";AAOA,AAAA,AAAMA,AAAeC;AAArB,AACE,AAAA,AAAA,AAAA,AAAIA,AAAcC,AAASC;;AAE7B,AAAA,AAAMC;AAAN,AACE,AAACC;;AAEH,AAAA,AAAMC,AACHC,AAAeC,AAAgBC;AADlC,AAEE,AAAMC,AAAK,AAAA,AAAA,AAAiBF;AAA5B,AACE,AAAA,AAAA,AAAA,AAAA,AAAA,AAACG,AAAUJ,AAAsBG,AAAqCD;;AAE1E,AAAA,AAAMG,AACHL;AADH,AAAA,AAAA,AAAA,AAAA,AAESM,AACA,AAACC,AAAQC,AAAUR,AACnB,AAAA,AAACS;;AAEV,AAAA,AAAMC,AACHV,AAAeW,AAAKT;AADvB,AAEE,AAAA,AAACU,AAAiBZ,AAAeW,AAAS,AAACN,AAAUL,AAAgBE;;AAEvE,AAAA,AAAA,AAAKW;AAML,AAAA,AAAMC,AAAgBpB;AAAtB,AACE,AAAMqB,AAAQ,AAACtB,AAAcC;AAA7B,AACE,AAAU,AAACmB,AAAAA,AAAAA,AAAuBE,AAAAA;AAAlC;;AAAA,AACErB;;;AAEN,AAAA,AAAUsB,AACPhB,AAAeW;AADlB,AAEM,AAACJ,AAAQG,AAASV,AAAeW,AACjC,AAAAM,AACA,AAAOH;;AAEb,AAAA,AAAMI,AAAOC;AAAb,AACE,AAAA,AAAK,AAAA,AAAA,AAAA,AAACE,AAAuBF;AAA7B,AAAAC,AACqBE;AADrB,AAEO,AAACC,AAAI,AAAID,AAAE1B;;AAFlB;;AAOF,AAAA,AAAM4B,AAAYxB,AAAemB;AAAjC,AACE,AAAAM,AAAc,AAACP,AAAMC;AAArB,AAAA,AAAAM;AAAA,AAAAA,AAASd;AAAT,AAiBM,AAACK,AAAiBhB,AAAe,AAAKW,AACtC,AAAO,AAAKjB,AAKZ;AALO,AACE,AAAA+B,AAAa,AAAChC,AAAcC;AAA5B,AAAA,AAAA+B;AAAA,AAAAA,AAASC;AAAT,AACE,AAAI,AAACH,AAAIG;;AACL,AAAA,AAAA,AAACC,AAAM3B,AAAe4B;;AAC1B,AAACJ,AAAAA,AAAAA,AAAWxB,AAAAA,AAAemB,AAAAA;;AAC9B,AAAKO;AAAL,AACE,AAACH,AAAIG;;AACL,AAAA,AAAA,AAACC,AAAM3B,AAAe4B;;;AAEpC,AAAA,AAAA,AAACD,AAAM3B,AAAe4B;;;AAE1B,AAAA,AAAMC,AAAW7B,AAAe8B;AAAhC,AACE,AAAMX,AAAO,AAACY,AAAwBD;AAAtC,AACE,AAAA,AAAA,AAACH,AAAM3B,AAAe4B;;AACtB,AAACJ,AAAWxB,AAAemB","names":["cljspad.env/error-message","result","cljs.core/ex-cause","cljs.core/ex-message","cljspad.env/state","cljs.js.empty_state","cljspad.env/init","compiler-state","sandbox-version","cb","path","shadow.cljs.bootstrap.browser/init","cljspad.env/eval-opts","cljs.js/js-eval","cljs.core.partial","shadow.cljs.bootstrap.browser/load","cljs.core.symbol","cljspad.env/eval-str","form","cljs.js.eval_str","cljspad.env/ignored-error-messages","cljspad.env/eval-result-xf","err-msg","cljspad.env/eval-str-promise","js/Promise","cljspad.env/read*","reader","e45048","cljs.tools.reader.read","e","cljs.core.prn","cljspad.env/eval-form*","temp__5733__auto__","err","cljs.core.swap_BANG_","cljs.core/assoc","cljspad.env/eval-form","source-str","cljs.tools.reader.reader_types.string_push_back_reader"],"sourcesContent":["(ns cljspad.env\n  (:refer-clojure :exclude [eval])\n  (:require [cljs.js :as cljs.js]\n            [shadow.cljs.bootstrap.browser :as boot]\n            [cljs.tools.reader :as reader]\n            [cljs.tools.reader.reader-types :refer [string-push-back-reader]]))\n\n(defn error-message [result]\n  (-> result :error ex-cause ex-message))\n\n(defn state []\n  (cljs.js/empty-state))\n\n(defn init\n  [compiler-state sandbox-version cb]\n  (let [path (str \"/sandbox/\" sandbox-version \"/bootstrap\")]\n    (boot/init compiler-state {:path path :load-on-init '#{sandbox.user}} cb)))\n\n(defn eval-opts\n  [compiler-state]\n  {:eval cljs.js/js-eval\n   :load (partial boot/load compiler-state)\n   :ns   (symbol \"sandbox.user\")})\n\n(defn eval-str\n  [compiler-state form cb]\n  (cljs.js/eval-str compiler-state form nil (eval-opts compiler-state) cb))\n\n(def ignored-error-messages\n  ;; This is a bit of a hack... (require '[...]) throws this exception\n  ;; in compiled mode, despite the require succeeding.\n  ;; Possibly a bug in shadow-cljs?\n  #{\"Namespace \\\"sandbox.user\\\" already declared.\"})\n\n(defn eval-result-xf [result]\n  (let [err-msg (error-message result)]\n    (when-not (ignored-error-messages err-msg)\n      result)))\n\n(defn ^js eval-str-promise\n  [compiler-state form]\n  (-> (partial eval-str compiler-state form)\n      (js/Promise.)\n      (.then eval-result-xf)))\n\n(defn read* [reader]\n  (try (reader/read {:eof nil} reader)\n       (catch :default e\n         (prn (-> e ex-message))\n         nil)))\n\n;; TODO: smarter reading. Tracking of line numbers where exceptions occur would be ideal...\n;; having errors reflected inside of monaco would be even cooler\n(defn eval-form* [compiler-state reader]\n  (if-let [form (read* reader)]\n    ;; TODO: another (possible) shadow or cljs.js bug\n    ;; cljs.js/eval returns exception: 'no *eval-fn* defined' on initial evaluation\n    ;; cljs.js/eval-str does not exhibit this behaviour.\n    ;;\n    ;; So unfortunately we have to read string then serialise the form back to a string...\n    ;;\n    ;; So why even read the editors contents at all?\n    ;; It appears that evaluating:\n    ;; (defn foo [] 1)\n    ;; (inc (foo))\n    ;;\n    ;; Will not evaluate, as it complains `foo` has not been defined when incrementing.\n    ;; This may be the intended behaviour of `:context :expr` in cljs.js, I am not sure.\n    ;;\n    ;; Breaking down the evaliation into a sequence of forms has the advantage of being able\n    ;; to eventually have better error handling/feedback (see comment at top of defn)\n    (-> (eval-str-promise compiler-state (str form))\n        (.then (fn [result]\n                 (if-let [err (error-message result)]\n                   (do (prn err)\n                       (swap! compiler-state assoc ::evaluating? false))\n                   (eval-form* compiler-state reader))))\n        (.catch (fn [err]\n                  (prn err)\n                  (swap! compiler-state assoc ::evaluating? false))))\n\n    (swap! compiler-state assoc ::evaluating? false)))\n\n(defn eval-form [compiler-state source-str]\n  (let [reader (string-push-back-reader source-str)]\n    (swap! compiler-state assoc ::evaluating? true)\n    (eval-form* compiler-state reader)))\n"]}